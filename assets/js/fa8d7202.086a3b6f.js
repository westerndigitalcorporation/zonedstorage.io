"use strict";(self.webpackChunkzonedstorage_io=self.webpackChunkzonedstorage_io||[]).push([[9825],{6724:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"filesystems/btrfs","title":"BTRFS","description":"BTRFS is a file system based on the copy-on-write (CoW) principle. This","source":"@site/docs/filesystems/btrfs.md","sourceDirName":"filesystems","slug":"/filesystems/btrfs","permalink":"/docs/filesystems/btrfs","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"btrfs","title":"BTRFS","sidebar_label":"BTRFS"},"sidebar":"docs","previous":{"title":"XFS","permalink":"/docs/filesystems/xfs"},"next":{"title":"F2FS","permalink":"/docs/filesystems/f2fs"}}');var t=s(4848),o=s(8453);const r={id:"btrfs",title:"BTRFS",sidebar_label:"BTRFS"},l="BTRFS File System",a={},d=[{value:"Usage",id:"usage",level:2},{value:"Implementation Overview",id:"implementation-overview",level:2},{value:"Super-block Management",id:"super-block-management",level:3},{value:"Block Allocation",id:"block-allocation",level:3},{value:"Device I/O Management",id:"device-io-management",level:3},{value:"Zone Capacity Support",id:"zone-capacity-support",level:3},{value:"Limitations",id:"limitations",level:3},{value:"System Requirements",id:"system-requirements",level:2}];function c(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"btrfs-file-system",children:"BTRFS File System"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"BTRFS"})," is a file system based on the copy-on-write (CoW) principle. This\nprinciple has the result that no block update can be written in-place."]}),"\n",(0,t.jsx)(n.admonition,{title:"System Requirements",type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Linux kernel: 5.12+ (for SMR hard-disks) or 5.16+ (for NVMe ZNS SSDs)."}),"\n",(0,t.jsx)(n.li,{children:"btrfs-progs: 5.12+ (for SMR hard-disks) or 5.15+ (for NVMe ZNS SSDs)."}),"\n",(0,t.jsxs)(n.li,{children:["util-linux: 2.38+. More information can be found ",(0,t.jsx)(n.a,{href:"/docs/tools/util-linux",children:"here"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.a,{href:"/docs/linux/sched#block-io-scheduler-configuration",children:"mq-deadline"})," block",(0,t.jsx)(n.br,{}),"\n","I/O scheduler for kernel versions prior to 6.10."]}),"\n"]})}),"\n",(0,t.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,t.jsxs)(n.p,{children:["First, check that your system meets the\n",(0,t.jsx)(n.a,{href:"/docs/filesystems/btrfs#system-requirements",children:"requirements"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["To format a zoned block device for use with ",(0,t.jsx)(n.em,{children:"BTRFS"}),", use the command\n",(0,t.jsx)(n.code,{children:"mkfs.btrfs"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-plaintext",children:"# mkfs.btrfs /dev/sda\nbtrfs-progs v6.15\nSee https://btrfs.readthedocs.io for more information.\n\nzoned: /dev/sdb: host-managed device detected, setting zoned feature\nResetting device zones /dev/sdb (111760 zones) ...\nNOTE: several default settings have changed in version 5.15, please make sure\n      this does not affect your deployments:\n      - DUP for metadata (-m dup)\n      - enabled no-holes (-O no-holes)\n      - enabled free-space-tree (-R free-space-tree)\n\nLabel:              (null)\nUUID:               176b7407-d046-43da-9f7f-d3512a2059ed\nNode size:          16384\nSector size:        4096\t(CPU page size: 4096)\nFilesystem size:    27.29TiB\nBlock group profiles:\n  Data:             single          512.00MiB\n  Metadata:         DUP             256.00MiB\n  System:           DUP             256.00MiB\nSSD detected:       no\nZoned device:       yes\n  Zone size:        256.00MiB\nFeatures:           extref, skinny-metadata, no-holes, free-space-tree, zoned\nChecksum:           crc32c\nNumber of devices:  1\nDevices:\n   ID        SIZE   ZONES  PATH\n    1    27.29TiB  111760  /dev/sdb\n"})}),"\n",(0,t.jsx)(n.p,{children:"The formatted block device can now be mounted. No other setup is necessary."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-plaintext",children:"# mount /dev/sda /mnt\n"})}),"\n",(0,t.jsx)(n.p,{children:"The kernel messages will show the following information."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-plaintext",children:"BTRFS: device fsid 176b7407-d046-43da-9f7f-d3512a2059ed devid 1 transid 8 /dev/sda (8:16) scanned by mount (3654)\nBTRFS info (device sdb): first mount of filesystem 176b7407-d046-43da-9f7f-d3512a2059ed\nBTRFS info (device sdb): using crc32c (crc32c-x86) checksum algorithm\nBTRFS info (device sdb): using free-space-tree\nBTRFS info (device sdb): host-managed zoned block device /dev/sdb, 111760 zones of 268435456 bytes\nBTRFS info (device sdb): zoned mode enabled with zone size 268435456\nBTRFS info (device sdb): checking UUID tree\n"})}),"\n",(0,t.jsx)(n.h2,{id:"implementation-overview",children:"Implementation Overview"}),"\n",(0,t.jsxs)(n.p,{children:["The implementation of ",(0,t.jsx)(n.em,{children:"BTRFS"})," zoned block devices support required several\nchanges in different areas of ",(0,t.jsx)(n.em,{children:"BTRFS"})," code."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Super-block management"}),"\n",(0,t.jsx)(n.li,{children:"Block allocation"}),"\n",(0,t.jsx)(n.li,{children:"Device I/O management"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"super-block-management",children:"Super-block Management"}),"\n",(0,t.jsxs)(n.p,{children:["Zoned block device support was added to ",(0,t.jsx)(n.em,{children:"BTRFS"})," with kernel 5.12. Because\nsuper-blocks are the only on-disk data structure with a fixed location in\n",(0,t.jsx)(n.em,{children:"BTRFS"}),", zoned block device support introduces the concept of log-structured\nsuper-blocks to eliminate in-place updates (overwrites) of fixed super block\nlocations. Zoned mode reserves two consecutive zones to hold each of the\nsuper-blocks (primary and backup super-blocks) in ",(0,t.jsx)(n.em,{children:"BTRFS"}),". When a new\nsuper-block is written, it is appended to its respective super-block zone.\nAfter the first super-block zone is filled, the next super block is written to\nthe second super-block zone and the first is reset. At mount time, ",(0,t.jsx)(n.em,{children:"BTRFS"}),"\ncan find the latest version of the super-block by looking at the position of\nthe zone write pointer of the super-block zones. The most recent and valid\nsuper-block is always the last  block stored before the write pointer\nposition."]}),"\n",(0,t.jsx)(n.h3,{id:"block-allocation",children:"Block Allocation"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Btrfs"})," block management relies on grouping blocks into ",(0,t.jsx)(n.em,{children:"block groups"}),".\nEach ",(0,t.jsx)(n.em,{children:"block group"})," is composed of one or more ",(0,t.jsx)(n.em,{children:"device extents"}),". The device\nextents of a block group may belong to different devices (e.g. in the case\nof a RAID volume). ZBD support changes the size of a device extent from its\ndefault size to the size of the device zones. This ensures that all device\nextents are always aligned to a zone."]}),"\n",(0,t.jsx)(n.p,{children:"Allocation of blocks within a block group is changed so that the allocation is\nalways sequential from the beginning of the block group. To do this, an\nallocation pointer is added to block groups and used as the allocation hint.\nThese changes ensure that blocks freed below the allocation pointer are\nignored, which results in sequential block allocation within each group\nregardless of the block group usage."}),"\n",(0,t.jsx)(n.h3,{id:"device-io-management",children:"Device I/O Management"}),"\n",(0,t.jsx)(n.p,{children:'Although the introduction of the allocation pointer ensures that blocks are\nallocated sequentially within groups (and therefore sequentially within zones),\nI/O operations that write out newly allocated blocks can be issued out of\norder, and this can cause errors when writing to sequential zones. This problem\nis solved by introducing a "write I/O request staging list" to each block group.\nThis list is used to delay the execution of unaligned write requests within a\ngiven block group.'}),"\n",(0,t.jsx)(n.p,{children:"The zones of a block group are reset to allow rewriting only when the block\ngroup is free (that is, when all the blocks within the block group are\nunused)."}),"\n",(0,t.jsxs)(n.p,{children:["When dealing with ",(0,t.jsx)(n.em,{children:"BTRFS"})," volumes that are composed of multiple disks,\nrestrictions are added to ensure that all the disks have the same zone model\n(and in the case of zoned block devices, the same zone size). This matches the\nexisting ",(0,t.jsx)(n.em,{children:"BTRFS"})," constraint that dictates that all device extents in a block\ngroup must have the same size."]}),"\n",(0,t.jsxs)(n.p,{children:["All writes to data block groups use ",(0,t.jsx)(n.a,{href:"/docs/introduction/zns#zone-append",children:"Zone Append\nwriting"}),", which makes it possible to maintain\na high queue depth without violating the device zone's sequential write\nconstraints. Every write to dedicated meta-data block groups is serialized\nwith a file-system-global zoned metadata I/O lock."]}),"\n",(0,t.jsx)(n.h3,{id:"zone-capacity-support",children:"Zone Capacity Support"}),"\n",(0,t.jsxs)(n.p,{children:["SSDs with Zoned Namespace support can have a per ",(0,t.jsx)(n.a,{href:"/docs/introduction/zns#zone-capacity-and-zone-size",children:"zone capacity that is smaller than the zone\nsize"}),". To support such\ndevices, ",(0,t.jsx)(n.em,{children:"BTRFS"})," ensures that block allocation and accounting considers only\nthe blocks in a zone that are within the zone capacity. This support for zone\ncapacity has been available since Linux kernel version 5.16. Also, since kernel\n5.16, ",(0,t.jsx)(n.em,{children:"BTRFS"}),' keeps track of the number of active zones on a device and issues\n"Zone Finish" commands as needed.']}),"\n",(0,t.jsx)(n.h3,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsxs)(n.p,{children:["Not all features currently available in ",(0,t.jsx)(n.em,{children:"BTRFS"})," are supported when using a zoned\nblock device."]}),"\n",(0,t.jsx)(n.p,{children:"These unavailable features include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"RAID 5 and 6 profiles support"}),"\n",(0,t.jsx)(n.li,{children:"NOCOW support"}),"\n",(0,t.jsx)(n.li,{children:"Support for fallocate(2)"}),"\n",(0,t.jsx)(n.li,{children:"Mixed data and meta-data block groups"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Support for RAID levels 0, 1 and 10 is still considered experimental and\nrequires a kernel compiled with the ",(0,t.jsx)(n.code,{children:"CONFIG_BTRFS_EXPERIMENTAL=y"})," configuration\noption as well as ",(0,t.jsx)(n.em,{children:"btrfs-progs"})," configured with the\n",(0,t.jsx)(n.code,{children:"./configure --enable-experimental"})," command."]}),"\n",(0,t.jsx)(n.h2,{id:"system-requirements",children:"System Requirements"}),"\n",(0,t.jsxs)(n.p,{children:["In order to use ",(0,t.jsx)(n.em,{children:"BTRFS"})," on zoned block devices, the following minimum system\nrequirements must be met:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Linux kernel 5.12 (for SMR hard-disks) or 5.16 (for NVMe ZNS SSDs)"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"btrfs-progs"})," 5.12 (for SMR hard-disks) or 5.15 (for NVMe ZNS SSDs)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"util-linux"})," 2.38"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The source code for ",(0,t.jsx)(n.em,{children:"btrfs-progs"})," ",(0,t.jsx)("a",{href:"https://github.com/kdave/btrfs-progs",target:"_blank",children:"is hosted on GitHub"}),". More information on ",(0,t.jsx)(n.em,{children:"util-linux"})," can be\nfound ",(0,t.jsx)(n.a,{href:"/docs/tools/util-linux",children:"here"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Kernels prior to version 6.10 and supporting ",(0,t.jsx)(n.em,{children:"BTRFS"})," on zoned block devices will\nautomatically select the ",(0,t.jsx)(n.em,{children:"mq_deadline"})," block IO scheduler by default for any\nSMR hard-disk that is used in a zoned ",(0,t.jsx)(n.em,{children:"BTRFS"})," volume. This\nensures ",(0,t.jsx)(n.a,{href:"/docs/linux/sched",children:"write ordering correctness"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["For NVMe ZNS SSD devices, the ",(0,t.jsx)(n.em,{children:"mq-deadline"})," scheduler must be set manually to\nensure that the regular write operations used by ",(0,t.jsx)(n.em,{children:"BTRFS"})," are delivered to the\ndevice in sequential order. For a NVMe Zoned Namespace device ",(0,t.jsx)(n.em,{children:"/dev/nvmeXnY"}),",\nthis is done with the following command:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-plaintext",children:"# echo mq-deadline > /sys/block/nvmeXnY/queue/scheduler\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Alternatively, the following udev rule can be used to automatically set the\n",(0,t.jsx)(n.em,{children:"mq-deadline"})," scheduler for all zoned block devices that have been formatted\nwith BTRFS."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-plain",metastring:"text",children:'SUBSYSTEM!="block", GOTO="btrfs_end"\nACTION!="add|change", GOTO="btrfs_end"\nENV{ID_FS_TYPE}!="btrfs", GOTO="btrfs_end"\n\nATTR{queue/zoned}=="host-managed", ATTR{queue/scheduler}="mq-deadline"\n\nLABEL="btrfs_end"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Using the ",(0,t.jsx)(n.em,{children:"mq_deadline"})," block IO scheduler for zoned block devices is not\nmandatory since kernel version 6.10. However, for performance reasons, the use\nof the ",(0,t.jsx)(n.em,{children:"mq_deadline"})," I/O scheduler is still recommended for SMR hard-disks. For\nNVMe ZNS SSDs, using the ",(0,t.jsx)(n.em,{children:"none"})," scheduler (no I/O scheduling) is recommended."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var i=s(6540);const t={},o=i.createContext(t);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);