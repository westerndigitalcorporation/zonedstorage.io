"use strict";(self.webpackChunkzonedstorage_io=self.webpackChunkzonedstorage_io||[]).push([[52],{4139:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>r});var s=t(7624),i=t(4552);const o={id:"zbd-emulation",title:"Getting started with Emulated Zoned Block Devices",sidebar_label:"Getting started with Emulated Zoned Block Devices"},a="Zoned Block Device Emulation",l={id:"getting-started/zbd-emulation",title:"Getting started with Emulated Zoned Block Devices",description:"Emulated zoned block devices make it possible to do application development and",source:"@site/docs/getting-started/zbd-emulation.md",sourceDirName:"getting-started",slug:"/getting-started/zbd-emulation",permalink:"/docs/getting-started/zbd-emulation",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"zbd-emulation",title:"Getting started with Emulated Zoned Block Devices",sidebar_label:"Getting started with Emulated Zoned Block Devices"},sidebar:"docs",previous:{title:"Setting-up a Zoned Storage Compatible Linux System",permalink:"/docs/getting-started/linux"},next:{title:"Getting Started with SMR Hard Disks",permalink:"/docs/getting-started/smr-disk"}},d={},r=[{value:"Zoned Block Device Emulation with <em>null_blk</em>",id:"zoned-block-device-emulation-with-null_blk",level:2},{value:"Creating a Zoned <em>null</em> Block Device \u2014 Simplest Case",id:"creating-a-zoned-null-block-device--simplest-case",level:3},{value:"Listing <em>null_blk</em> Zoned Block Device Parameters",id:"listing-null_blk-zoned-block-device-parameters",level:3},{value:"Creating a <em>null_blk</em> Zoned Block Device \u2014 More Advanced Cases (configfs)",id:"creating-a-null_blk-zoned-block-device--more-advanced-cases-configfs",level:3},{value:"Deleting a <em>null_blk</em> Zoned Block Device",id:"deleting-a-null_blk-zoned-block-device",level:3},{value:"Deleting ZBD that were created with modprobe",id:"deleting-zbd-that-were-created-with-modprobe",level:4},{value:"Deleting ZBD that were created with configfs",id:"deleting-zbd-that-were-created-with-configfs",level:4},{value:"Emulating SMR HDD",id:"emulating-smr-hdd",level:3},{value:"Emulating SSD with ZNS support",id:"emulating-ssd-with-zns-support",level:3},{value:"SMR Hard Disk Emulation with <em>scsi_debug</em>",id:"smr-hard-disk-emulation-with-scsi_debug",level:2},{value:"Creating an Emulated ZBC Disk",id:"creating-an-emulated-zbc-disk",level:3},{value:"Verifying The Emulated Disk",id:"verifying-the-emulated-disk",level:3},{value:"Using zbc_report_zones",id:"using-zbc_report_zones",level:4},{value:"Using blkzone",id:"using-blkzone",level:4},{value:"SMR Hard Disk Emulation with <em>tcmu-runner</em>",id:"smr-hard-disk-emulation-with-tcmu-runner",level:2},{value:"tcmu-runner ZBC File Handler",id:"tcmu-runner-zbc-file-handler",level:3},{value:"Verifying The Emulated Disk",id:"verifying-the-emulated-disk-1",level:3},{value:"Zoned Namespace Device Emulation with <em>QEMU</em>",id:"zoned-namespace-device-emulation-with-qemu",level:2},{value:"Creating an Emulated Zoned Namespace",id:"creating-an-emulated-zoned-namespace",level:3},{value:"Creating the Backstore",id:"creating-the-backstore",level:4},{value:"Using truncate to create an Emulated Zone Namespace Backstore",id:"using-truncate-to-create-an-emulated-zone-namespace-backstore",level:5},{value:"Using dd to create an Emulated Zone Namespace Backstore",id:"using-dd-to-create-an-emulated-zone-namespace-backstore",level:5},{value:"Creating a ZNS and using the Backstore File",id:"creating-a-zns-and-using-the-backstore-file",level:4},{value:"Verifying an Emulated Zoned Namespace",id:"verifying-an-emulated-zoned-namespace",level:3},{value:"Using an Emulated Zoned Namespace",id:"using-an-emulated-zoned-namespace",level:3},{value:"Emulated Zoned Namespace Options",id:"emulated-zoned-namespace-options",level:3},{value:"<em>QEMU</em> Execution Example",id:"qemu-execution-example",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.M)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"zoned-block-device-emulation",children:"Zoned Block Device Emulation"}),"\n",(0,s.jsx)(n.p,{children:"Emulated zoned block devices make it possible to do application development and\nkernel tests even if you do not have access to zoned storage hardware."}),"\n",(0,s.jsx)(n.p,{children:"There are several ways available to create an emulated zoned block device."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"null_blk"})})," kernel block device driver: this is by far the easiest\nmethod to emulate a zoned block device with different zone configurations\nmimicking both SMR and ZNS devices."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"scsi-debug"})})," kernel block device driver: this driver is simple to\nuse but only makes it possible to create emulated SCSI ZBC hard disks."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"tcmu-runner"})})," SCSI device emulation: this application uses a regular\nfile as its storage backstore. It can emulate host-aware and host-managed\nZBC SCSI disks. Disks created with ",(0,s.jsx)(n.em,{children:"tcmu-runner"})," are treated by the Linux\nkernel as though they were physical disks."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"QEMU"})})," open source machine emulator and virtualizer: recent versions\nof QEMU support the emulation of NVMe devices with Zoned Namespace support. These use\nregular files on the host as a backstores. Within a guest VM, an emulated\nZNS device acts like a physical device."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"zoned-block-device-emulation-with-null_blk",children:["Zoned Block Device Emulation with ",(0,s.jsx)(n.em,{children:"null_blk"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsxs)(n.a,{href:"https://www.kernel.org/doc/Documentation/block/null_blk.txt",children:["Linux\xae ",(0,s.jsx)(n.em,{children:"null_blk"}),"\ndriver"]})," is a\npowerful tool that can emulate several types of block devices. Since kernel\nversion 4.19, the ",(0,s.jsx)(n.em,{children:"null_blk"})," driver has been able to emulate zoned block\ndevices. Because memory backup has been added to the ",(0,s.jsx)(n.em,{children:"null_blk"})," device for\ndata-reading and data-writing operations, the ",(0,s.jsx)(n.em,{children:"null_blk"})," driver can be used for\napplication development and tests."]}),"\n",(0,s.jsxs)(n.h3,{id:"creating-a-zoned-null-block-device--simplest-case",children:["Creating a Zoned ",(0,s.jsx)(n.em,{children:"null"})," Block Device \u2014 Simplest Case"]}),"\n",(0,s.jsxs)(n.p,{children:["The simplest way to create a ",(0,s.jsx)(n.em,{children:"null_blk"})," emulated zoned block device is to\nspecify ",(0,s.jsx)(n.code,{children:"zoned=1"})," as an argument following the ",(0,s.jsx)(n.em,{children:"modprobe null_blk"})," command\non the command line, as in the following example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# modprobe null_blk nr_devices=1 zoned=1\n"})}),"\n",(0,s.jsx)(n.p,{children:"This creates a single, host-managed zoned block device that has a zone size of\n256M and a total capacity of 250 GB (1000 zones). This simple command creates\nno conventional zones."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# blkzone report /dev/nullb0\n  start: 0x000000000, len 0x080000, cap 0x080000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x000080000, len 0x080000, cap 0x080000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x000100000, len 0x080000, cap 0x080000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x000180000, len 0x080000, cap 0x080000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n...\n  start: 0x01f300000, len 0x080000, cap 0x080000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x01f380000, len 0x080000, cap 0x080000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"listing-null_blk-zoned-block-device-parameters",children:["Listing ",(0,s.jsx)(n.em,{children:"null_blk"})," Zoned Block Device Parameters"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"null_blk"})," kernel module accepts many arguments that can adjust the zone\nconfiguration of the emulated device. These arguments can be listed by using\nthe ",(0,s.jsx)(n.em,{children:"modinfo"})," command and can be modified by using the ",(0,s.jsx)(n.em,{children:"configfs"})," command after\nthe ",(0,s.jsx)(n.em,{children:"null_blk"})," module is loaded."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"# modinfo null_blk\n...\nparm:           zoned:Make device as a host-managed zoned block device. Default: false (bool)\nparm:           zone_size:Zone size in MB when block device is zoned. Must be power-of-two: Default: 256 (ulong)\nparm:           zone_capacity:Zone capacity in MB when block device is zoned. Can be less than or equal to zone size. Default: Zone size (ulong)\nparm:           zone_nr_conv:Number of conventional zones when block device is zoned. Default: 0 (uint)\nparm:           zone_max_open:Maximum number of open zones when block device is zoned. Default: 0 (no limit) (uint)\nparm:           zone_max_active:Maximum number of active zones when block device is zoned. Default: 0 (no limit) (uint)\n"})}),"\n",(0,s.jsx)(n.p,{children:"The parameters that are related to zoned-device emulation are shown in the table\nbelow."}),"\n",(0,s.jsx)("center",{children:(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Argument"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Value"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"zoned"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"0 or 1"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Disable or enable zoned mode (default: disabled)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"zone_size"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"zone size in MiB"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"The size of each zone (default: 256)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"zone_capacity"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"zone capacity in MiB"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"The capacity of each zone (default: zone size)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"zone_nr_conv"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"number"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Number of conventional zones (default: 0)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"zone_max_open"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"number"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Maximum number of open zones (default: 0, meaning no limit)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"zone_max_active"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"number"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Maximum number of active zones (default: 0, meaning no limit)"})]})]})]})}),"\n",(0,s.jsxs)(n.h3,{id:"creating-a-null_blk-zoned-block-device--more-advanced-cases-configfs",children:["Creating a ",(0,s.jsx)(n.em,{children:"null_blk"})," Zoned Block Device \u2014 More Advanced Cases (configfs)"]}),"\n",(0,s.jsxs)(n.p,{children:["To create an emulated zoned block device with ",(0,s.jsx)(n.em,{children:"null_blk"}),", as shown above, the\n",(0,s.jsx)(n.em,{children:"modprobe"})," command can be used. Additional parameters can be passed to this\ncommand to configure the emulated disk."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# modprobe null_blk nr_devices=1 \\\n\tzoned=1 \\\n\tzone_nr_conv=4 \\\n\tzone_size=64 \\\n"})}),"\n",(0,s.jsx)(n.p,{children:"In this example, the arguments mean the following:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"nr_devices=1"})," means that only one (1) device will be created."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"zoned=1"})," means that all devices that are created will be zoned devices."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"zone_nr_conv=4"})," sets the number of conventional zones to four (4)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"zone_size=64"})," sets the size of each zone to sixty-four (64) megabytes."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"configfs"})," interface of the ",(0,s.jsx)(n.em,{children:"null_blk"})," driver provides a way to create\nemulated zoned block devices. The ",(0,s.jsx)(n.em,{children:"configfs"})," parameters of the ",(0,s.jsx)(n.em,{children:"null_blk"}),"\ndriver can be listed by running the following commands:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# modprobe null_blk nr_devices=0\n\n# cat /sys/kernel/config/nullb/features\nmemory_backed,discard,bandwidth,cache,badblocks,zoned,zone_size,zone_capacity,zone_nr_conv,zone_max_open,zone_max_active\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"configfs"})," interface can be used to script the creation of emulated zoned\nblock devices with a range of possible zone configurations. An example is\nprovided below."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n\nif [ $# != 4 ]; then\n        echo "Usage: $0 <sect size (B)> <zone size (MB)> <nr conv zones> <nr seq zones>"\n        exit 1\nfi\n\nscriptdir=$(cd $(dirname "$0") && pwd)\n\nmodprobe null_blk nr_devices=0 || return $?\n\nfunction create_zoned_nullb()\n{\n        local nid=0\n        local bs=$1\n        local zs=$2\n        local nr_conv=$3\n        local nr_seq=$4\n\n        cap=$(( zs * (nr_conv + nr_seq) ))\n\n        while [ 1 ]; do\n                if [ ! -b "/dev/nullb$nid" ]; then\n                        break\n                fi\n                nid=$(( nid + 1 ))\n        done\n\n        dev="/sys/kernel/config/nullb/nullb$nid"\n        mkdir "$dev"\n\n        echo $bs > "$dev"/blocksize\n        echo 0 > "$dev"/completion_nsec\n        echo 0 > "$dev"/irqmode\n        echo 2 > "$dev"/queue_mode\n        echo 1024 > "$dev"/hw_queue_depth\n        echo 1 > "$dev"/memory_backed\n        echo 1 > "$dev"/zoned\n\n        echo $cap > "$dev"/size\n        echo $zs > "$dev"/zone_size\n        echo $nr_conv > "$dev"/zone_nr_conv\n\n        echo 1 > "$dev"/power\n\n        echo mq-deadline > /sys/block/nullb$nid/queue/scheduler\n\n        echo "$nid"\n}\n\nnulldev=$(create_zoned_nullb $1 $2 $3 $4)\necho "Created /dev/nullb$nulldev"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This script (",(0,s.jsx)(n.em,{children:"nullblk-zoned.sh"}),") takes four arguments:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"the sector size in bytes of the emulated device"}),"\n",(0,s.jsx)(n.li,{children:"the device zone size in MiB"}),"\n",(0,s.jsx)(n.li,{children:"the number of conventional zones (which can be 0)"}),"\n",(0,s.jsx)(n.li,{children:"the number of sequential write required zones."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Memory-backing for written sectors can be turned on with this script (the\nrelevant part is ",(0,s.jsx)(n.code,{children:"memory_backed=1"})," or, as it appears in this example,\n",(0,s.jsx)(n.code,{children:'echo 1 > "$dev"/memory_backed'}),"). This enables runtime persistence of the\ndata written to the sectors of the emulated device. The writen data is lost when\nthe emulated device is destroyed."]}),"\n",(0,s.jsx)(n.p,{children:"For example, a small zoned device with 4 conventional zones and 8 sequential\nwrite-required zones of 64 MiB can be created with the following command:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# nullblk-zoned.sh 4096 64 4 8\nCreated /dev/nullb0\n# blkzone report /dev/nullb0 \n  start: 0x000000000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 0(nw) [type: 1(CONVENTIONAL)]\n  start: 0x000020000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 0(nw) [type: 1(CONVENTIONAL)]\n  start: 0x000040000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 0(nw) [type: 1(CONVENTIONAL)]\n  start: 0x000060000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 0(nw) [type: 1(CONVENTIONAL)]\n  start: 0x000080000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x0000a0000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x0000c0000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x0000e0000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x000100000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n...\n  start: 0x000820000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x000840000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x000860000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"deleting-a-null_blk-zoned-block-device",children:["Deleting a ",(0,s.jsx)(n.em,{children:"null_blk"})," Zoned Block Device"]}),"\n",(0,s.jsxs)(n.p,{children:["There are two ways to delete ",(0,s.jsx)(n.em,{children:"null_blk"})," zoned block devices. One way is used to\ndelete ",(0,s.jsx)(n.em,{children:"null_blk"})," zoned block devices that were created using ",(0,s.jsx)(n.em,{children:"modprobe"})," and\nthe other way is used to delete ",(0,s.jsx)(n.em,{children:"null_blk"})," zoned block devices that were\ncreated using ",(0,s.jsx)(n.em,{children:"configfs"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"deleting-zbd-that-were-created-with-modprobe",children:"Deleting ZBD that were created with modprobe"}),"\n",(0,s.jsxs)(n.p,{children:["Emulated devices created by using ",(0,s.jsx)(n.em,{children:"modprobe"})," (and not created using ",(0,s.jsx)(n.em,{children:"configfs"}),")\ncan be deleted by removing the ",(0,s.jsx)(n.em,{children:"null_blk"})," kernel module:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# rmmod null_blk\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["This command does not delete emulated devices that were created through the\n",(0,s.jsx)(n.em,{children:"configfs"})," interface."]})}),"\n",(0,s.jsx)(n.h4,{id:"deleting-zbd-that-were-created-with-configfs",children:"Deleting ZBD that were created with configfs"}),"\n",(0,s.jsxs)(n.p,{children:["The following script is the counterpart of the zoned block device creation\nscript shown above. It can be used to destroy ",(0,s.jsx)(n.em,{children:"null_blk"})," devices created\nthrough ",(0,s.jsx)(n.em,{children:"configfs"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n\nif [ $# != 1 ]; then\n\techo "Usage: $0 <nullb ID>"\n\texit 1\nfi\n\nnid=$1\n\nif [ ! -b "/dev/nullb$nid" ]; then\n\techo "/dev/nullb$nid: No such device"\n\texit 1\nfi\n\necho 0 > /sys/kernel/config/nullb/nullb$nid/power\nrmdir /sys/kernel/config/nullb/nullb$nid\n\necho "Destroyed /dev/nullb$nid"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"emulating-smr-hdd",children:"Emulating SMR HDD"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"nullblk-zoned.sh"})," script makes it possible to create zoned block devices\nthat correspond to a possible configuration of an SMR hard disk, with no limit\non the maximum number of open zones. This script can be modified to add a limit\nto the number of open zones on the emulated device (the ",(0,s.jsx)(n.em,{children:"zone_max_open"}),"\nparameter controls this), to more faithfully emulate an SMR HDD's\ncharacteristics."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"zone_capacity"})," and ",(0,s.jsx)(n.em,{children:"zone_max_active"})," parameters should not be used when the\nemulated device is meant to mimic the characteristics of an SMR hard disk."]}),"\n",(0,s.jsx)(n.h3,{id:"emulating-ssd-with-zns-support",children:"Emulating SSD with ZNS support"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"zone_capacity"})," and ",(0,s.jsx)(n.em,{children:"zone_max_active"})," parameters make it possible to\ncreate an emulated zoned block device that mimics the characteristics of a\nSSD with Zoned Namespace support. The ",(0,s.jsx)(n.em,{children:"zone_capacity"})," parameter is used to specify\nthe number of sectors in each zone that can be read and written. The\n",(0,s.jsx)(n.em,{children:"zone_max_active"})," argument is used to specify a limit on the number of\nzones that can be in the closed state, the implicit-open state, or the\nexplicit-open state."]}),"\n",(0,s.jsxs)(n.h2,{id:"smr-hard-disk-emulation-with-scsi_debug",children:["SMR Hard Disk Emulation with ",(0,s.jsx)(n.em,{children:"scsi_debug"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"scsi_debug"})," kernel module can be used to create emulated ZBC SCSI disks\nthat use memory backing to store data, which is written to sectors.\nBecause this method uses memory as a backing store, the creation of large disks\nrequires a host with a large amount of DRAM."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"This method stores sector data using volatile memory. This means that the data\nwritten to the emulated device will not survive the device's destruction and the\ndata written to this emulated device will not survive a host reboot."})}),"\n",(0,s.jsx)(n.h3,{id:"creating-an-emulated-zbc-disk",children:"Creating an Emulated ZBC Disk"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"scsi_debug"})," ZBC disks can be created using ",(0,s.jsx)(n.em,{children:"modprobe"})," with arguments.  The\nfollowing is an example that creates a host managed ZBC disk with 16GiB\ncapacity, 64MiB zones, and 32 conventional zones."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# modprobe scsi_debug \\\n\tmax_luns=1 \\\n\tsector_size=4096 \\\n\tdev_size_mb=16384 \\\n\tzbc=managed \\\n\tzone_size_mb=64 \\\n\tzone_nr_conv=32\n"})}),"\n",(0,s.jsxs)(n.p,{children:["After the disk has been created, it can be examined by using the ",(0,s.jsx)(n.em,{children:"lsscsi"}),"\ncommand."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# lsscsi -g\n...\n[11:0:0:0]   zbc     Linux    scsi_debug       0190  /dev/sdj   /dev/sg9\n...\n"})}),"\n",(0,s.jsx)(n.p,{children:'The vendor field of the disk is set to "scsi_debug". The kernel messages\nalso show the process whereby this disk came online.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# dmesg\n...\nscsi_debug:sdebug_driver_probe: scsi_debug: trim poll_queues to 0. poll_q/nr_hw = (0/1)\nscsi host11: scsi_debug: version 0190 [20200710]\n                 dev_size_mb=16384, opts=0x0, submit_queues=1, statistics=0\nscsi 11:0:0:0: Direct-Access-ZBC Linux    scsi_debug       0190 PQ: 0 ANSI: 7\nsd 11:0:0:0: Power-on or device reset occurred\nsd 11:0:0:0: Attached scsi generic sg9 type 20\nsd 11:0:0:0: [sdj] Host-managed zoned block device\nsd 11:0:0:0: [sdj] 4194304 4096-byte logical blocks: (17.2 GB/16.0 GiB)\nsd 11:0:0:0: [sdj] Write Protect is off\nsd 11:0:0:0: [sdj] Mode Sense: 5b 00 10 08\nsd 11:0:0:0: [sdj] Write cache: enabled, read cache: enabled, supports DPO and FUA\nsd 11:0:0:0: [sdj] Optimal transfer size 4194304 bytes\nsd 11:0:0:0: [sdj] 256 zones of 16384 logical blocks\nsd 11:0:0:0: [sdj] Attached SCSI disk\n"})}),"\n",(0,s.jsx)(n.h3,{id:"verifying-the-emulated-disk",children:"Verifying The Emulated Disk"}),"\n",(0,s.jsxs)(n.p,{children:["The zone configuration of the emulated disk can be inspected by using\n",(0,s.jsx)(n.a,{href:"/docs/tools/libzbc",children:(0,s.jsx)(n.em,{children:"libzbc"})}),", ",(0,s.jsx)(n.a,{href:"/docs/tools/sg3utils",children:(0,s.jsx)(n.em,{children:"sg3utils"})})," and\n",(0,s.jsx)(n.a,{href:"/docs/tools/util-linux",children:(0,s.jsx)(n.em,{children:"util-linux"})})," tools."]}),"\n",(0,s.jsx)(n.h4,{id:"using-zbc_report_zones",children:"Using zbc_report_zones"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.a,{href:"/docs/tools/libzbc#zone-information",children:(0,s.jsx)(n.em,{children:"zbc_report_zones"})})," to verify the\nzone configuration of the newly-created emulated ZBC disk:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# zbc_report_zones /dev/sg9\nDevice /dev/sg9:\n    Vendor ID: Linux scsi_debug 0190\n    SCSI ZBC device interface, Host-managed zone model\n    33554432 512-bytes sectors\n    4194304 logical blocks of 4096 B\n    4194304 physical blocks of 4096 B\n    17.180 GB capacity\n    Read commands are unrestricted\n    4096 KiB max R/W size\n    Maximum number of open sequential write required zones: 8\n    256 zones from 0, reporting option 0x00\n256 / 256 zones:\nZone 00000: type 0x1 (Conventional), cond 0x0 (Not-write-pointer), sector 0, 131072 sectors\nZone 00001: type 0x1 (Conventional), cond 0x0 (Not-write-pointer), sector 131072, 131072 sectors\nZone 00002: type 0x1 (Conventional), cond 0x0 (Not-write-pointer), sector 262144, 131072 sectors\n...\nZone 00031: type 0x1 (Conventional), cond 0x0 (Not-write-pointer), sector 4063232, 131072 sectors\nZone 00032: type 0x2 (Sequential-write-required), cond 0x1 (Empty), reset recommended 0, non_seq 0, sector 4194304, 131072 sectors, wp 4194304\nZone 00033: type 0x2 (Sequential-write-required), cond 0x1 (Empty), reset recommended 0, non_seq 0, sector 4325376, 131072 sectors, wp 4325376\n...\nZone 00254: type 0x2 (Sequential-write-required), cond 0x1 (Empty), reset recommended 0, non_seq 0, sector 33292288, 131072 sectors, wp 33292288\nZone 00255: type 0x2 (Sequential-write-required), cond 0x1 (Empty), reset recommended 0, non_seq 0, sector 33423360, 131072 sectors, wp 33423360\n"})}),"\n",(0,s.jsx)(n.h4,{id:"using-blkzone",children:"Using blkzone"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.a,{href:"/docs/tools/util-linux#zone-report",children:(0,s.jsx)(n.em,{children:"blkzone"})}),' to verify the zone\nconfiguration of the newly-created emulated ZBC disk. This displays the same\ninformation that is returned by "zbc_report_zones", but it is displayed in a\ndifferent format:']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# blkzone report /dev/sdj\n  start: 0x000000000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 0(nw) [type: 1(CONVENTIONAL)]\n  start: 0x000020000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 0(nw) [type: 1(CONVENTIONAL)]\n  start: 0x000040000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 0(nw) [type: 1(CONVENTIONAL)]\n...\n  start: 0x0003e0000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 0(nw) [type: 1(CONVENTIONAL)]\n  start: 0x000400000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x000420000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n...\n  start: 0x001fc0000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x001fe0000, len 0x020000, cap 0x020000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"smr-hard-disk-emulation-with-tcmu-runner",children:["SMR Hard Disk Emulation with ",(0,s.jsx)(n.em,{children:"tcmu-runner"})]}),"\n",(0,s.jsxs)(n.p,{children:["Detailed information on how to install and operate ",(0,s.jsx)(n.em,{children:"tcmu-runner"})," can be found\nin the ",(0,s.jsx)(n.a,{href:"/docs/tools/tcmu-runner",children:"tcmu-runner ZBC Disk Emulation"})," chapter of\nthe ",(0,s.jsx)(n.a,{href:"/docs/tools",children:"Tools and Libraries"})," Guide."]}),"\n",(0,s.jsx)(n.h3,{id:"tcmu-runner-zbc-file-handler",children:"tcmu-runner ZBC File Handler"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"ZBC file handler"})," is an internal device handler of ",(0,s.jsx)(n.em,{children:"tcmu-runner"})," that\nemulates a ZBC SCSI disk and uses a file as a backstore. The ",(0,s.jsx)(n.em,{children:"tcmu-runner"}),"\ninfrastructure connects the emulated disk to a virtual HBA that has been\nimplemented as a kernel driver. This structure provides a command path for the\nemulated disk that is identical to the command path that would be available if a\nphysical disk were in its place. Applications and kernel components will not\nperceive any difference."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"/docs/tools/tcmu-runner",children:"tcmu-runner ZBC Disk Emulation"})," chapter of the\n",(0,s.jsx)(n.a,{href:"/docs/tools",children:"Tools and Libraries"})," guide describes in more\ndetail the options available for creating emulated disks. These include the disk\nzone model, the disk zone size, the disk capacity, and the number of\nconventional zones of the disk."]}),"\n",(0,s.jsxs)(n.p,{children:["The following example shows how to create a small (20 GB) host-managed ZBC disk\nthat has 10 conventional zones and a 256 MiB zone size. In this example, the\nemulated disk capacity is stored in the file ",(0,s.jsx)(n.em,{children:"/var/local/zbc0.raw"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# targetcli\ntargetcli shell version 2.1.fb49\nCopyright 2011-2013 by Datera, Inc and others.\nFor help on commands, type 'help'.\n\n/> cd /backstores/user:zbc\n/backstores/user:zbc> create name=zbc0 size=20G cfgstring=model-HM/zsize-256/conv-10@/var/local/zbc0.raw\nCreated user-backed storage object zbc0 size 21474836480.\n/backstores/user:zbc> cd /loopback\n/loopback> create\nCreated target naa.500140529100d742.\n/loopback> cd naa.500140529100d742/luns\n/loopback/naa...9100d742/luns> create /backstores/user:zbc/zbc0 0\nCreated LUN 0.\n/loopback/naa...9100d742/luns> cd /\n/> ls\no- / ..................................................................... [...]\n  o- backstores .......................................................... [...]\n  | o- block .............................................. [Storage Objects: 0]\n  | o- fileio ............................................. [Storage Objects: 0]\n  | o- pscsi .............................................. [Storage Objects: 0]\n  | o- ramdisk ............................................ [Storage Objects: 0]\n  | o- user:fbo ........................................... [Storage Objects: 0]\n  | o- user:poma .......................................... [Storage Objects: 0]\n  | o- user:zbc ........................................... [Storage Objects: 1]\n  |   o- zbc0  [model-HM/zsize-256/conv-10@/var/local/zbc0.raw (20.0GiB) activated]\n  |     o- alua ............................................... [ALUA Groups: 1]\n  |       o- default_tg_pt_gp ................... [ALUA state: Active/optimized]\n  o- iscsi ........................................................ [Targets: 0]\n  o- loopback ..................................................... [Targets: 1]\n  | o- naa.500140529100d742 ............................. [naa.50014059e05d5424]\n  |   o- luns ........................................................ [LUNs: 1]\n  |     o- lun0 ................................. [user/zbc0 (default_tg_pt_gp)]\n  o- vhost ........................................................ [Targets: 0]\n/> exit\n"})}),"\n",(0,s.jsx)(n.h3,{id:"verifying-the-emulated-disk-1",children:"Verifying The Emulated Disk"}),"\n",(0,s.jsxs)(n.p,{children:["You can verify that the emulated disk has been identified and initialized by\nthe kernel in the same way that you verify the kernel identification and\ninitialization of Serial ATA disks and SAS disks, as discussed in the ",(0,s.jsx)(n.a,{href:"smr-disk",children:"Getting\nstarted with an SMR disk"})," chapter."]}),"\n",(0,s.jsxs)(n.p,{children:["Identify the emulated disk by looking at the disk vendor ID that is displayed\nby the ",(0,s.jsx)(n.em,{children:"lsscsi"})," utility:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# lsscsi -g\n[2:0:0:0]    disk    ATA      INTEL SSDSC2CT18 335u  /dev/sda   /dev/sg0\n[5:0:0:0]    zbc     ATA      HGST HSH721415AL T220  /dev/sdb   /dev/sg1\n[11:0:1:0]   zbc     LIO-ORG  TCMU ZBC device  0002  /dev/sdc   /dev/sg2\n"})}),"\n",(0,s.jsx)(n.p,{children:'In this example, the emulated disk is listed with the device vendor name\n"LIO-ORG" and the device model name is "TCMU ZBC device".'}),"\n",(0,s.jsx)(n.p,{children:"As with physical ZBC and ZAC disks, the kernel messages will show that the\ndrive has been identified and initialized:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# dmesg\n...\nscsi host11: TCM_Loopback\nscsi 11:0:1:0: Direct-Access-ZBC LIO-ORG  TCMU ZBC device  0002 PQ: 0 ANSI: 5\nsd 11:0:1:0: Attached scsi generic sg2 type 20\nsd 11:0:1:0: [sdc] Host-managed zoned block device\nsd 11:0:1:0: [sdc] 41943040 512-byte logical blocks: (21.5 GB/20.0 GiB)\nsd 11:0:1:0: [sdc] 80 zones of 524288 logical blocks\nsd 11:0:1:0: [sdc] Write Protect is off\nsd 11:0:1:0: [sdc] Mode Sense: 0f 00 00 00\nsd 11:0:1:0: [sdc] Write cache: enabled, read cache: enabled, doesn't support DPO or FUA\nsd 11:0:1:0: [sdc] Optimal transfer size 65536 bytes\nsd 11:0:1:0: [sdc] Attached SCSI disk\n\n...\n"})}),"\n",(0,s.jsxs)(n.p,{children:['The kernel identifies the emulated disk in the same way that it would identify\na physical SAS host managed disk (that is, with the device type\n"',(0,s.jsx)(n.em,{children:"Direct-Access-ZBC"}),'").']}),"\n",(0,s.jsxs)(n.p,{children:["The emulated disk can now be used in the same manner as any physical disk. For\ninstance, the ",(0,s.jsx)(n.em,{children:"blkzone"})," or ",(0,s.jsx)(n.em,{children:"zbc_report_zones"})," utilities can be used to inspect\nthe disk zone configuration:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# zbc_report_zones /dev/sdc\nDevice /dev/sdc:\n    Vendor ID: LIO-ORG TCMU ZBC device 0002\n    Zoned block device interface, Host-managed zone model\n    41943040 512-bytes sectors\n    41943040 logical blocks of 512 B\n    41943040 physical blocks of 512 B\n    21.475 GB capacity\n    Read commands are unrestricted\n    Maximum number of open sequential write required zones: 35\n    80 zones from 0, reporting option 0x00\n80 / 80 zones:\nZone 00000: type 0x1 (Conventional), cond 0x0 (Not-write-pointer), sector 0, 524288 sectors\nZone 00001: type 0x1 (Conventional), cond 0x0 (Not-write-pointer), sector 524288, 524288 sectors\nZone 00002: type 0x1 (Conventional), cond 0x0 (Not-write-pointer), sector 1048576, 524288 sectors\nZone 00003: type 0x1 (Conventional), cond 0x0 (Not-write-pointer), sector 1572864, 524288 sectors\nZone 00004: type 0x1 (Conventional), cond 0x0 (Not-write-pointer), sector 2097152, 524288 sectors\nZone 00005: type 0x1 (Conventional), cond 0x0 (Not-write-pointer), sector 2621440, 524288 sectors\nZone 00006: type 0x1 (Conventional), cond 0x0 (Not-write-pointer), sector 3145728, 524288 sectors\nZone 00007: type 0x1 (Conventional), cond 0x0 (Not-write-pointer), sector 3670016, 524288 sectors\nZone 00008: type 0x1 (Conventional), cond 0x0 (Not-write-pointer), sector 4194304, 524288 sectors\nZone 00009: type 0x1 (Conventional), cond 0x0 (Not-write-pointer), sector 4718592, 524288 sectors\nZone 00010: type 0x2 (Sequential-write-required), cond 0x1 (Empty), reset recommended 0, non_seq 0, sector 5242880, 524288 sectors, wp 5242880\nZone 00011: type 0x2 (Sequential-write-required), cond 0x1 (Empty), reset recommended 0, non_seq 0, sector 5767168, 524288 sectors, wp 5767168\n...\nZone 00078: type 0x2 (Sequential-write-required), cond 0x1 (Empty), reset recommended 0, non_seq 0, sector 40894464, 524288 sectors, wp 40894464\nZone 00079: type 0x2 (Sequential-write-required), cond 0x1 (Empty), reset recommended 0, non_seq 0, sector 41418752, 524288 sectors, wp 41418752\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"zoned-namespace-device-emulation-with-qemu",children:["Zoned Namespace Device Emulation with ",(0,s.jsx)(n.em,{children:"QEMU"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:(0,s.jsx)("a",{href:"https://www.qemu.org/",target:"_blank",children:"QEMU"})})," has supported the\nemulation of NVMe namespaces since version 1.6. But the emulation of zoned\nnamespaces has been supported only since version 6.0 of ",(0,s.jsx)(n.em,{children:"QEMU"}),". If the host\nLinux distribution does not provide ",(0,s.jsx)(n.em,{children:"QEMU"})," version 6.0 or above, ",(0,s.jsx)(n.em,{children:"QEMU"})," has\nto be compiled from source. Detailed information on how to compile and install\n",(0,s.jsx)(n.em,{children:"QEMU"})," from source can be found ",(0,s.jsx)("a",{href:"https://www.qemu.org/download/#source",target:"_blank",children:"on the QEMU download page"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"creating-an-emulated-zoned-namespace",children:"Creating an Emulated Zoned Namespace"}),"\n",(0,s.jsxs)(n.p,{children:["To create an emulated zoned namespace, you must first have a backing-store file\nthat the namespace can use. The size of the file determines the capacity of the\nnamespace that will be seen from the guest OS running in the ",(0,s.jsx)(n.em,{children:"QEMU"})," virtual\nmachine."]}),"\n",(0,s.jsxs)(n.p,{children:["For example: to create a 32GiB zoned namespace, you must first create a 32 GiB\nfile on the host. This can be done by using the ",(0,s.jsx)(n.em,{children:"truncate"})," command to\ncreate a sparse file or by using the ",(0,s.jsx)(n.em,{children:"dd"})," command to create a fully allocated\nfile."]}),"\n",(0,s.jsx)(n.h4,{id:"creating-the-backstore",children:"Creating the Backstore"}),"\n",(0,s.jsx)(n.p,{children:"This guide provides instructions for two methods of creating the backstore file:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Using truncate"}),"\n",(0,s.jsx)(n.li,{children:"Using dd"}),"\n"]}),"\n",(0,s.jsx)(n.h5,{id:"using-truncate-to-create-an-emulated-zone-namespace-backstore",children:"Using truncate to create an Emulated Zone Namespace Backstore"}),"\n",(0,s.jsxs)(n.p,{children:["Run the following command to use ",(0,s.jsx)(n.code,{children:"truncate"})," to create a backstore file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# truncate -s 32G /var/lib/qemu/images/zns.raw\n\n# ls -l /var/lib/qemu/images/zns.raw\n-rw-r--r-- 1 root root 34359738368 Jun 21 15:13 /var/lib/qemu/images/zns.raw\n"})}),"\n",(0,s.jsx)(n.h5,{id:"using-dd-to-create-an-emulated-zone-namespace-backstore",children:"Using dd to create an Emulated Zone Namespace Backstore"}),"\n",(0,s.jsxs)(n.p,{children:["Run the following command to use ",(0,s.jsx)(n.code,{children:"dd"})," to create a backstore file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# dd if=/dev/zero of=/var/lib/qemu/images/zns.raw bs=1M count=32768\n32768+0 records in\n32768+0 records out\n34359738368 bytes (34 GB, 32 GiB) copied, 11.4072 s, 3.0 GB/s\n\n# ls -l /var/lib/qemu/images/zns.raw\n-rw-r--r-- 1 root root 34359738368 Jun 22 11:22 /var/lib/qemu/images/zns.raw\n"})}),"\n",(0,s.jsx)(n.h4,{id:"creating-a-zns-and-using-the-backstore-file",children:"Creating a ZNS and using the Backstore File"}),"\n",(0,s.jsxs)(n.p,{children:["Execute ",(0,s.jsx)(n.em,{children:"QEMU"})," with command-line options and arguments to create a zoned\nnamespace that uses the backstore file as storage. In the following example,\nthe backstore file is used to emulate a zoned namespace that has zones of 64\nMiB and a zone capacity of 62 MiB. The namespace block size is 4096 B.  The\nnamespace is set to allow at most 16 open zones and 32 active zones."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# /usr/local/bin/qemu-system-x86_64 \\\n...\n-device nvme,id=nvme0,serial=deadbeef,zoned.zasl=5 \\\n-drive file=${znsimg},id=nvmezns0,format=raw,if=none \\\n-device nvme-ns,drive=nvmezns0,bus=nvme0,nsid=1,logical_block_size=4096,\\\nphysical_block_size=4096,zoned=true,zoned.zone_size=64M,zoned.\\\nzone_capacity=62M,zoned.max_open=16,zoned.max_active=32,\\\nuuid=5e40ec5f-eeb6-4317-bc5e-c919796a5f79\n...\n"})}),"\n",(0,s.jsx)(n.h3,{id:"verifying-an-emulated-zoned-namespace",children:"Verifying an Emulated Zoned Namespace"}),"\n",(0,s.jsxs)(n.p,{children:["If your guest operating system is a Linux distribution and the Linux\ndistribution's kernel version is higher than 5.9.0, the emulated SSD with ZNS\nsupport can be checked by using the ",(0,s.jsx)(n.em,{children:"nvme"})," command (see ",(0,s.jsx)(n.a,{href:"/docs/tools/zns",children:"Linux Tools for\nZNS"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"# nvme list\nNode             SN                   Model                                    Namespace Usage                      Format           FW Rev\n---------------- -------------------- ---------------------------------------- --------- -------------------------- ---------------- --------\n/dev/nvme0n1     deadbeef             QEMU NVMe Ctrl                           1          34.36  GB /  34.36  GB      4 KiB +  0 B   1.0\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"lsscsi"})," utility shows the emulated NVMe device:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"# lsscsi -g\n[2:0:0:0]    cd/dvd  QEMU     QEMU DVD-ROM     2.5+  /dev/sr0   /dev/sg0\n[N:0:0:1]    disk    QEMU NVMe Ctrl__1                          /dev/nvme0n1  -\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Using the ",(0,s.jsx)(n.em,{children:"blkzone"})," utility, the namespace zone configuration can be inspected."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"# blkzone report /dev/nvme0n1 | less\n  start: 0x000000000, len 0x020000, cap 0x01f000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x000020000, len 0x020000, cap 0x01f000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x000040000, len 0x020000, cap 0x01f000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x000060000, len 0x020000, cap 0x01f000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x000080000, len 0x020000, cap 0x01f000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n...\n  start: 0x003f80000, len 0x020000, cap 0x01f000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x003fa0000, len 0x020000, cap 0x01f000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x003fc0000, len 0x020000, cap 0x01f000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x003fe0000, len 0x020000, cap 0x01f000, wptr 0x000000 reset:0 non-seq:0, zcond: 1(em) [type: 2(SEQ_WRITE_REQUIRED)]\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"The total number of zones of the namespace directly depends on the size of the\nbackstore file used and on the zone size configured. In the above example, the\nemulated namespace has 512 zones (32 GiB / 64 MiB)."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"# cat /sys/block/nvme0n1/queue/nr_zones \n512\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If the emulated namespace is configured with a zone capacity smaller than the\nzone size, the total capacity defined by the backstore file will not be\nusable. The effective usable capacity can be reported using ",(0,s.jsx)(n.em,{children:"blkzone"})," with the\n",(0,s.jsx)(n.em,{children:"capacity"})," command, as shown here:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"# blkzone capacity /dev/nvme0n1\n0x003e00000\n"})}),"\n",(0,s.jsx)(n.p,{children:"In this case, the namespace's effective storage capacity is 0x003e00000\n(65011712) 512-Byte sectors, which is equivalent to 512 zones of 62 MiB\ncapacity."}),"\n",(0,s.jsx)(n.h3,{id:"using-an-emulated-zoned-namespace",children:"Using an Emulated Zoned Namespace"}),"\n",(0,s.jsxs)(n.p,{children:["The behavior of a ",(0,s.jsx)(n.em,{children:"QEMU"}),"-emulated SSD with ZNS support is fully compliant with the\nNVMe Zoned Namespace Command Set specification, with one exception: the state of namespace zones is\nnot persistent across restarts of the ",(0,s.jsx)(n.em,{children:"QEMU"})," emulation. The state of zones is\npreserved only as long as ",(0,s.jsx)(n.em,{children:"QEMU"})," is running, even if the guest operating system\nis rebooted. If ",(0,s.jsx)(n.em,{children:"QEMU"})," is restarted and the same backstore file is used, then\nthe guest operating system will see the namespace with all zones in the empty\nstate."]}),"\n",(0,s.jsx)(n.h3,{id:"emulated-zoned-namespace-options",children:"Emulated Zoned Namespace Options"}),"\n",(0,s.jsxs)(n.p,{children:["The implementation of NVMe device emulation and ZNS namespace emulation in\n",(0,s.jsx)(n.em,{children:"QEMU"})," provides several configuration options to control the characteristics of\nthe device. The full list of options and parameters is\ndocumented ",(0,s.jsx)("a",{href:"https://qemu-project.gitlab.io/qemu/system/nvme.html",target:"_blank",children:"here"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The options and parameters related to Zoned Namespaces are as follows."}),"\n",(0,s.jsx)("center",{children:(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Option"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Default Value"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"zoned.zasl=UINT32"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Zone Append Size Limit. If left at the default (0), the zone append size limit will be equal to the maximum data transfer size (MDTS). Otherwise, the zone append size limit is equal to 2 to the power of zasl multiplied by the minimum memory page size (4096 B), but cannot exceed the maximum data transfer size."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["zoned.zone_size=",(0,s.jsx)(n.em,{children:"SIZE"})]}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"128MiB"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Define the zone size (ZSZE)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["zoned.zone_capacity=",(0,s.jsx)(n.em,{children:"SIZE"})]}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Define the zone capacity (ZCAP). If left at the default (0), the zone capacity will equal the zone size."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["zoned.descr_ext_size=",(0,s.jsx)(n.em,{children:"UINT32"})]}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Set the Zone Descriptor Extension Size (ZDES). Must be a multiple of 64 bytes."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["zoned.cross_read=",(0,s.jsx)(n.em,{children:"BOOL"})]}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"off"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:'Set to "on" to allow reads to cross zone boundaries.'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["zoned.max_active=",(0,s.jsx)(n.em,{children:"UINT32"})]}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"0"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Set the maximum number of active resources (MAR). The default (0) allows all zones to be active."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["zoned.max_open=",(0,s.jsx)(n.em,{children:"UINT32"})]}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"0"}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["Set the maximum number of open resources (MOR).  The default (0) allows all zones to be open. If ",(0,s.jsx)(n.code,{children:"zoned.max_active"})," is specified, this value must be less than or equal to that."]})]})]})]})}),"\n",(0,s.jsxs)(n.h3,{id:"qemu-execution-example",children:[(0,s.jsx)(n.em,{children:"QEMU"})," Execution Example"]}),"\n",(0,s.jsxs)(n.p,{children:["The following script uses ",(0,s.jsx)(n.em,{children:"QEMU"})," to run a virtual machine with 8 CPU cores,\n16 GiB of memory, and bridged networking. The bridge device ",(0,s.jsx)(n.em,{children:"virbr0"})," is assumed\nalready to exist. The last device added to the virtual machine on the ",(0,s.jsx)(n.em,{children:"QEMU"}),"\ncommand line is a 32 GiB NVMe device with Zoned Namespace support."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'#!/bin/sh\n\n#\n# Some variables\n#\nbridge="virbr0"\nvmimg="/var/lib/qemu/boot-disk.qcow2"\nznsimg="/var/lib/qemu/zns.raw"\n\n#\n# Run QEMU\n#\nsudo /usr/local/bin/qemu-system-x86_64 \\\n-name guest=FedoraServer34 \\\n-machine pc-q35-5.2,accel=kvm \\\n-m 16384 \\\n-smp 8,sockets=8,cores=1,threads=1 \\\n-rtc base=utc,driftfix=slew \\\n-nographic \\\n-no-hpet \\\n-global ICH9-LPC.disable_s3=1 \\\n-global ICH9-LPC.disable_s4=1 \\\n-boot strict=on \\\n-audiodev none,id=noaudio \\\n-object rng-random,id=objrng0,filename=/dev/urandom \\\n-msg timestamp=on \\\n-device pcie-root-port,port=0x10,chassis=1,id=pci.1,bus=pcie.0,multifunction=on,addr=0x2 \\\n-netdev bridge,id=hostnet0,br=${bridge} \\\n-device virtio-net-pci,netdev=hostnet0,id=net0,mac=52:54:00:fa:2d:b9,bus=pci.1,addr=0x0 \\\n-device pcie-root-port,port=0x11,chassis=2,id=pci.2,bus=pcie.0,addr=0x2.0x1 \\\n-blockdev node-name="vmstorage",driver=qcow2,file.driver=file,file.filename="${vmimg}",file.node-name="vmstorage.qcow2",file.discard=unmap \\\n-device virtio-blk-pci,bus=pci.2,addr=0x0,drive="vmstorage",id=virtio-disk0,bootindex=1 \\\n-device pcie-root-port,port=0x12,chassis=3,id=pci.3,bus=pcie.0,addr=0x2.0x2 \\\n-device virtio-balloon-pci,id=balloon0,bus=pci.3,addr=0x0 \\\n-device pcie-root-port,port=0x13,chassis=4,id=pci.4,bus=pcie.0,addr=0x2.0x3 \\\n-device virtio-rng-pci,rng=objrng0,id=rng0,bus=pci.4,addr=0x0 \\\n-device pcie-root-port,port=0x14,chassis=5,id=pci.5,bus=pcie.0,addr=0x2.0x4 \\\n-device nvme,id=nvme0,serial=deadbeef,zoned.zasl=5,bus=pci.5 \\\n-drive file=${znsimg},id=nvmezns0,format=raw,if=none \\\n-device nvme-ns,drive=nvmezns0,bus=nvme0,nsid=1,logical_block_size=4096,physical_block_size=4096,zoned=true,zoned.zone_size=64M,zoned.zone_capacity=62M,zoned.max_open=16,zoned.max_active=32,uuid=5e40ec5f-eeb6-4317-bc5e-c919796a5f79\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.M)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},4552:(e,n,t)=>{t.d(n,{I:()=>l,M:()=>a});var s=t(1504);const i={},o=s.createContext(i);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);