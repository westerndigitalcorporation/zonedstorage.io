"use strict";(self.webpackChunkzonedstorage_io=self.webpackChunkzonedstorage_io||[]).push([[5460],{1204:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"benchmarking/fio/overview","title":"Overview","description":"The Flexible I/O Tester (fio) was originally written as a test tool for the","source":"@site/docs/benchmarking/fio/overview.md","sourceDirName":"benchmarking/fio","slug":"/benchmarking/fio/overview","permalink":"/docs/benchmarking/fio/overview","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"overview","title":"Overview","sidebar_label":"Overview","slug":"/benchmarking/fio/overview"},"sidebar":"docs","previous":{"title":"Overview","permalink":"/docs/benchmarking"},"next":{"title":"Examples for SMR hard-disks","permalink":"/docs/benchmarking/fio/smr-fio"}}');var t=i(4848),s=i(8453);const r={id:"overview",title:"Overview",sidebar_label:"Overview",slug:"/benchmarking/fio/overview"},a="Overview",d={},l=[{value:"fio Zoned Block Device Support",id:"fio-zoned-block-device-support",level:2},{value:"Command Line Options",id:"command-line-options",level:3},{value:"Restrictions",id:"restrictions",level:3},{value:"Examples",id:"examples",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"overview",children:"Overview"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.em,{children:"Flexible I/O Tester (fio)"})," was originally written as a test tool for the\nkernel block I/O stack. Over the years, ",(0,t.jsx)(n.em,{children:"fio"})," however gained many features and\ndetailed performance statistics output that turned this tool into a standard\nbenchmark application for storage devices."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"fio"})," source code is available on ",(0,t.jsx)("a",{href:"https://github.com/axboe/fio",target:"_blank",children:"GitHub"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"fio-zoned-block-device-support",children:"fio Zoned Block Device Support"}),"\n",(0,t.jsxs)(n.p,{children:["Support for zoned block devices was added to ",(0,t.jsx)(n.em,{children:"fio"})," with version 3.9. All\nprevious versions do not provide guarantees for write command ordering with\nhost managed zoned block devices. Executing workloads is still possible, but\nrequires writing complex ",(0,t.jsx)(n.em,{children:"fio"})," scripts."]}),"\n",(0,t.jsx)(n.h3,{id:"command-line-options",children:"Command Line Options"}),"\n",(0,t.jsxs)(n.p,{children:["Changes to ",(0,t.jsx)(n.em,{children:"fio"})," to support zoned block devices include several new options\nallowing a user to control zoned block device compliant workloads. ",(0,t.jsx)(n.em,{children:"fio"}),"\nalready implemented the option ",(0,t.jsx)(n.code,{children:"--zonemode"})," which allows defining workloads\noperating on disjoint ranges of blocks. This option was reused to define the new\n",(0,t.jsx)(n.em,{children:"zbd"})," zone mode."]}),"\n",(0,t.jsxs)(n.p,{children:["When the ",(0,t.jsx)(n.em,{children:"zbd"})," zone mode is used by an ",(0,t.jsx)(n.em,{children:"fio"})," job, the ",(0,t.jsx)(n.code,{children:"--zonerange"})," option is\nignored and the ",(0,t.jsx)(n.code,{children:"--zonesize"})," option is automatically set to the device zone\nsize. Furthermore, the behavior of read and write commands is modified as\nfollows."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Read and write commands are split when a zone boundary is crossed."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'For sequential writes, the write stream is always started from a zone write\npointer position. If the next zone to be written is not empty, the write\nstream "jumps" to that zone write pointer and resumes.'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"For random write workloads, write commands are always issued at the write\npointer position of the target zone of the write command."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Any write command targeting a sequential zone that is full (entirely written)\nwill trigger a reset of the zone write pointer before issuing the write I/O."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["By default, all read commands always target written sectors, that is, sectors\nbetween the start sector and the write pointer position of sequential write\nzones. This behavior can be disabled, allowing read commands to be issued to\nany sector, using the new option ",(0,t.jsx)(n.code,{children:"read_beyond_wp"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Additionally, finer control over the workload operation can be added with the\nfollowing new options."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"--max_open_zones"})," This option limits the number of zones that are being\nwritten by a workload. With this option, a random write workload cannot issue\nwrite commands targeting more zones than the limit set. Once a zone that is\nbeing written becomes full, another zone is chosen and writes are allowed to\ntarget the zone, resulting in a constant number of zones being written always\nat most equal to the ",(0,t.jsx)(n.code,{children:"max_open_zones"})," limit."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"--zone_reset_threshold and --zone_reset_frequency"})," These two options allow\na user to emulate the execution of zone reset commands being issued by an\napplication."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["In addition to these options, the ",(0,t.jsx)(n.em,{children:"zbd"})," zone mode automatically enables job\nsynchronization to ensure that a workload spanning multiple threads or processes\ncan concurrently execute write I/Os targeting the same zone."]}),"\n",(0,t.jsxs)(n.p,{children:["To indicate a zone unit for integer parameters, the ",(0,t.jsx)(n.code,{children:"z"})," suffix can be used (e.g.\n",(0,t.jsx)(n.code,{children:"--offset_increment=8z"}),", ",(0,t.jsx)(n.code,{children:"--size=8z"}),", ...)."]}),"\n",(0,t.jsx)(n.h3,{id:"restrictions",children:"Restrictions"}),"\n",(0,t.jsxs)(n.p,{children:["As discussed in the ",(0,t.jsx)(n.a,{href:"/docs/linux/overview#zbd-support-restrictions",children:"kernel support\ndocument"}),", using\ndirect write I/O is mandatory for zoned block devices. The ",(0,t.jsx)(n.em,{children:"zbd"})," zone mode,\nwhen enabled, enforces this requirement by checking that the option\n",(0,t.jsx)(n.code,{children:"--direct=1"})," is specified for any job executing write I/Os."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"--offset"})," and ",(0,t.jsx)(n.code,{children:"--size"})," options must specify values that are aligned to the\ndevice zone size."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"--numjobs"})," parameter should not exceed the ",(0,t.jsx)(n.code,{children:"--max_open_zones"})," option for\nwrite workloads, otherwise jobs that do not obtain their required resources\n(e.g. opening a zone) immediately quit silently."]}),"\n",(0,t.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"smr-fio",children:"SMR fio Examples"}),": fio benchmarking examples for SMR hard-disks."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"zns-fio",children:"ZNS fio Examples"}),": fio benchmarking examples for NVMe ZNS devices."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var o=i(6540);const t={},s=o.createContext(t);function r(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);