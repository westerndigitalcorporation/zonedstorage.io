"use strict";(self.webpackChunkzonedstorage_io=self.webpackChunkzonedstorage_io||[]).push([[6052],{8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(6540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}},8958:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"linux/sched","title":"Write Ordering Control","description":"Historically, the Linux&reg; kernel block I/O stack (i.e., the block layer and","source":"@site/docs/linux/sched.md","sourceDirName":"linux","slug":"/linux/sched","permalink":"/docs/linux/sched","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"sched","title":"Write Ordering Control","sidebar_label":"Write Ordering Control"},"sidebar":"docs","previous":{"title":"Zoned Block Device User Interface","permalink":"/docs/linux/zbd-api"},"next":{"title":"Zoned Block Device Partition Support","permalink":"/docs/linux/part"}}');var s=i(4848),r=i(8453);const o={id:"sched",title:"Write Ordering Control",sidebar_label:"Write Ordering Control"},a="Write Ordering Control",l={},d=[{value:"Zone Write Locking",id:"zone-write-locking",level:2},{value:"Initial Implementation",id:"initial-implementation",level:3},{value:"Improved Implementation: Block I/O Scheduler",id:"improved-implementation-block-io-scheduler",level:3},{value:"Zone Write Plugging",id:"zone-write-plugging",level:2},{value:"Block I/O Scheduler Configuration",id:"block-io-scheduler-configuration",level:2},{value:"Manual Configuration",id:"manual-configuration",level:3},{value:"Automatic Persistent Configuration",id:"automatic-persistent-configuration",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"write-ordering-control",children:"Write Ordering Control"})}),"\n",(0,s.jsx)(n.p,{children:"Historically, the Linux\xae kernel block I/O stack (i.e., the block layer and\nthe SCSI layer) have never guaranteed the exact execution order of block I/O\nrequests. The exact processing order of block I/O requests cannot be guaranteed\ndue to the asynchronous nature of the execution in the kernel of block I/O\nrequests and the necessity of a fine-granularity locking model for the device\nrequest queue,  to minimize lock-contention overhead when multiple contexts\nsimultaneously issue I/O requests to a block device."}),"\n",(0,s.jsx)(n.p,{children:"A direct result of this design is the inability to give guarantees to a well-\nbehaving zoned block device compliant application that write commands for a zone\nwill be delivered sequentially in increasing LBA order (matching the zone\nsequential write constraint)."}),"\n",(0,s.jsxs)(n.p,{children:["To address this problem, the kernel zoned block device support implements\neither ",(0,s.jsx)(n.em,{children:"zone write locking"}),"  or ",(0,s.jsx)(n.em,{children:"zone write plugging"})," to ensure that write\nrequests are processed sequentially per zone."]}),"\n",(0,s.jsx)(n.h2,{id:"zone-write-locking",children:"Zone Write Locking"}),"\n",(0,s.jsx)(n.p,{children:"Zone write locking implements a per-zone write lock to serialize the execution\nof write requests that target the same zone. This feature does not guarantee\nthat write commands are always issued at the location of the zone write\npointer: this is the responsibility of the write I/O issuer. Zone write\nlocking only guarantees that the order in which write commands are issued\nby an application, file system, or device mapper target will be respected by\nthe block I/O stack. A well-behaved user of zoned block devices will thus\navoid unaligned write command failures."}),"\n",(0,s.jsx)(n.p,{children:"Zone write locking does not affect read commands in any way. Read requests are\nnot serialized and processed in exactly the same manner as with regular block\ndevices."}),"\n",(0,s.jsx)(n.h3,{id:"initial-implementation",children:"Initial Implementation"}),"\n",(0,s.jsx)(n.p,{children:"Zone write locking was first implemented in kernel 4.10 in the SCSI disk\ndriver (below the block layer), operating on requests already passed to the\ndevice dispatch queue by the block I/O scheduler."}),"\n",(0,s.jsxs)(n.p,{children:["This early implementation relied on the fact that the SCSI layer could delay\nissuing any request to the device. By maintaining a bitmap with one bit per\nzone, the SCSI disk driver marked a zone as ",(0,s.jsx)(n.em,{children:"locked"})," whenever it saw a write\ncommand. This algorithm is presented here in more detail:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If the next command to be dispatched to the device is not a write command,\nthen the command is dispatched immediately."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If the next command to by dispatched is a write command, then the zone\nwrite lock bit for the target zone of the command is inspected."}),"\n",(0,s.jsxs)("ol",{type:"a",children:[(0,s.jsx)("li",{children:(0,s.jsx)(n.p,{children:"If the target zone of the write command is not write locked (i.e., the\nbit is not set), then the zone is locked and the write command issued\nto the device.  Both operations are atomically executed under the\ndevice request queue spinlock."})}),(0,s.jsx)("li",{children:(0,s.jsx)(n.p,{children:"If the target zone is already locked (i.e., the bit is set), then the\nSCSI disk driver temporarily delays issuing the command to the device\nuntil the zone write lock is released."})}),(0,s.jsx)("li",{children:(0,s.jsx)(n.p,{children:"When a write command completes, the zone write lock for the target zone\nof the command is released and the dispatch process is resumed. This\nmeans that if the command at the head of the dispatch queue targets the\nsame zone, then the command can be issued (when the write command\ncompletes) (step 2.a)."})})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Zone write locking that is implemented as shown above also prevents the\nunintended reordering of commands by the SAS HBAs or SATA adapters. The ",(0,s.jsx)(n.em,{children:"AHCI"}),"\nspecifications do not define a clear order for issuing commands to devices. As a\nresult, many chipsets are unable to guarantee the proper order of commands."]})}),"\n",(0,s.jsx)(n.p,{children:"Although this implementation provides write-ordering guarantees for the legacy\nsingle-queue block I/O path and is not dependent upon any particular HBA, it\nhas several limitations:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Potential performance degradation"})," Any write command to any zone results\nin the command dispatch processing being stalled. This prevents all other\ncommand from being dispatched, including read commands. This can limit\nperformance benefits that can be obtained with device-level command\nreordering when operating the device at high queue depth. The extreme case is\nan application issuing a write stream to a zone with asynchronous I/O system\ncalls (e.g. ",(0,s.jsx)(n.code,{children:"io_submit()"}),"). In this case, the sequential write commands\nwould be queued in sequence in the device dispatch queue, resulting in the\ndrive being operated at a queue depth of one, one write command at a time."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"No support for the block multi-queue I/O path"})," Unlike the legacy single\nqueue block I/O interface, the multi-queue block I/O implementation does not\nheavily rely on the device queue spin-lock to process block I/O requests\nissued by the disk users (applications or kernel components). This results in\npotential block I/O request reordering happening before requests are passed\non to the device dispatch queue and the ineffectiveness of zone write\nlocking."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These limitations led to the development of a new implementation of zone write\nlocking at a higher level in the I/O stack, using the block layer I/O\nschedulers."}),"\n",(0,s.jsx)(n.h3,{id:"improved-implementation-block-io-scheduler",children:"Improved Implementation: Block I/O Scheduler"}),"\n",(0,s.jsx)(n.p,{children:"By moving zone write locking implementation higher up in the I/O stack, the\nblock multi-queue (and SCSI multi-queue) infrastructure can also be supported.\nThis improvement was added with kernel version 4.16 and the SCSI layer\nimplementation of zone write locking was removed."}),"\n",(0,s.jsxs)(n.p,{children:["This new implementation of zone write locking relies on the block layer\n",(0,s.jsx)(n.em,{children:"deadline"})," and ",(0,s.jsx)(n.em,{children:"mq-deadline"})," I/O schedulers and also addresses the performance\nlimitations of the previous implementation. In detail, the new algorithm is as\nfollows."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"deadline"})," and ",(0,s.jsx)(n.em,{children:"mq-deadline"})," schedulers operate by grouping commands per\ntype (reads vs writes) and always processsing these two groups of commands\nseparately, e.g. first issuing many reads, then many writes. This improves\nperformance by taking advantage of hardware features such as device-level\nread-ahead."]})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If the scheduler is processing read commands..."}),"\n",(0,s.jsxs)("ol",{type:"a",children:[(0,s.jsx)("li",{children:(0,s.jsx)(n.p,{children:"...the first command queued in the list of read commands is allowed to\nproceed and is submitted to the device dispatch queue."})}),(0,s.jsx)("li",{children:(0,s.jsx)(n.p,{children:"If no read commands are available, activate write processing (step 2)."})}),(0,s.jsx)("li",{children:(0,s.jsx)(n.p,{children:"If the read-command processing time limit is reached, write-command\nprocessing (step 2) is activated to avoid write-command starvation."})}),(0,s.jsx)("li",{children:(0,s.jsx)(n.p,{children:"If read commands are still available, restart at step 1."})})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"When processing write commands, the list of write commands queued in the\nscheduler is scanned in order starting with the command at the head of the\nLBA ordered list or the first command in the arrival-time ordered list (when\nthere is a risk of starving commands)."}),"\n",(0,s.jsxs)("ol",{type:"a",children:[(0,s.jsx)("li",{children:(0,s.jsx)(n.p,{children:"If the target zone of the first write command is not write locked (zone\nbitmap bit not set), then the zone is locked and the write command is\nissued to the device. Both operations are atomically executed under a\nspinlock maintained by the scheduler."})}),(0,s.jsx)("li",{children:(0,s.jsx)(n.p,{children:"If the target zone is already locked (bit set), the command is skipped\nand the first write command that targets a different zone is searched\nfor in the LBA ordered list of write commands. If such a command is\nfound, step 2 is executed again."})}),(0,s.jsx)("li",{children:(0,s.jsxs)(n.p,{children:["If all queued write commands target locked zones, the scheduler\noperation mode (batch mode) is switched to ",(0,s.jsx)(n.em,{children:"read"})," and step 1 is called."]})})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"When a write command completes, the zone write lock for the target zone of\nthe command is released and the scheduler is activated. Operation is\nresumed at step 1 or 2 depending on the current batch mode."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"From this algorithm, it is clear that the device can now be operated at higher\nqueue depth and that only sequential writes that target the same zone will be\nthrottled. All read commands can proceed, always, and write commands that\ntarget different zones do not impact each other."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"This new implementation does not guarantee overall command ordering.  Guarantees\nare given only for write commands that target the same zone.  The dispatch order\nof write commands that target different zones may be changed by the scheduler.\nFor any single sequential zone, at any time, there is always at most a single\nwrite command in-flight being executed. Overall disk operation at high queue\ndepth is possible when there are read accesses and if multiple zones are being\nwritten simultaneously."})}),"\n",(0,s.jsx)(n.h2,{id:"zone-write-plugging",children:"Zone Write Plugging"}),"\n",(0,s.jsx)(n.p,{children:"Zone write plugging was introduced with kernel 6.10.0 as a replacement for zone\nwrite locking. Zone write plugging is very similar in concept to zone write\nlocking: it limits the number of in-flight write I/O request to at most one per\nzone to avoid breaking the sequential write pattern of the I/O issuer."}),"\n",(0,s.jsxs)(n.p,{children:["However, unlike zone write locking which is implemented in the ",(0,s.jsx)(n.em,{children:"mq-deadline"}),"\nblock I/O scheduler, zone write plugging is implemented directly in the upper\nsubmission path of the block layer and thus does not depend on the block I/O\nscheduler being used."]}),"\n",(0,s.jsx)(n.p,{children:"Zone write locking operates using a per-zone list of block I/O write requests\n(BIOs) to throttle write operations to a zone. If a zone is not being written\nalready when a new write operation is submitted, the write request is executed\nimmediately. Otherwise, the new write request is added to the tail of the list\nof write BIOs for the target zone. Upon completion of the in-flight write for\nthe zone, the first write BIO in the zone list is automatically issued, thus\nalways maintaining at most one write I/O per zone at any time."}),"\n",(0,s.jsx)(n.p,{children:"Similarly to zone write locking, zone write plugging does not affect read\ncommands in any way. Read requests are not serialized using the per zone list of\nBIO."}),"\n",(0,s.jsx)(n.h2,{id:"block-io-scheduler-configuration",children:"Block I/O Scheduler Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"deadline"})," and ",(0,s.jsx)(n.em,{children:"mq-deadline"})," schedulers must be enabled in the kernel\ncompilation configuration for kernels that use zone write locking, that is,\nkernels from version 4.16 up to version 6.9. From kernel 6.10 onward, the\n",(0,s.jsx)(n.em,{children:"mq-deadline"})," scheduler can still be used for zoned block devices (e.g. SMR\nHDDs) but is not a requirement for write ordering control."]}),"\n",(0,s.jsxs)(n.p,{children:["Refer to the section\n",(0,s.jsx)(n.a,{href:"/docs/linux/config#write-ordering-control",children:"Write Ordering Control"})," for details."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["The legacy single queue block I/O path was removed from the kernel in version\n5.0. As of kernel version 5.0, the ",(0,s.jsx)(n.em,{children:"deadline"})," scheduler cannot be enabled. The\n",(0,s.jsx)(n.em,{children:"mq-deadline"})," scheduler is the only zoned block device compliant scheduler for\nkernels implementing zone write locking (kernel versions from 5.0 up to 6.9)."]})}),"\n",(0,s.jsx)(n.h3,{id:"manual-configuration",children:"Manual Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["A system may define a default I/O scheduler other than ",(0,s.jsx)(n.em,{children:"deadline"})," or\n",(0,s.jsx)(n.em,{children:"mq-deadline"}),". The block I/O scheduler for a zoned block device can be checked\nwith the following command."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# cat /sys/block/sdb/queue/scheduler\n[none] mq-deadline kyber bfq\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If the block I/O scheduler selected is not ",(0,s.jsx)(n.em,{children:"deadline"})," nor ",(0,s.jsx)(n.em,{children:"mq-deadline"})," as in\nthe example above, the scheduler can be changed with the following command."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# echo mq-deadline > /sys/block/sdb/queue/scheduler\n# cat sys/block/sdb/queue/scheduler\n[mq-deadline] kyber bfq none\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"deadline"})," is an alias for the ",(0,s.jsx)(n.em,{children:"mq-deadline"})," scheduler. The following command\ncan therefore be used to get the same results in environments that use the\nlegacy single queue I/O path (kernels 4.16 to 4.20) and environments that use\nthe block multi-queue infrastructure (the sole possibility as of kernel\nversion 5.0)."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"# echo deadline > /sys/block/sdb/queue/scheduler\n# cat sys/block/sdb/queue/scheduler\n[mq-deadline] kyber bfq none\n"})}),"\n",(0,s.jsx)(n.h3,{id:"automatic-persistent-configuration",children:"Automatic Persistent Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["Automatically configuring the ",(0,s.jsx)(n.em,{children:"deadline"})," scheduler at system boot time can\nalso be done using a ",(0,s.jsx)(n.em,{children:"udev"})," rule. The procedure for defining a new ",(0,s.jsx)(n.em,{children:"udev"})," rule\nvaries slightly between distributions. Refer to your distribution\ndocumentation for details."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:'ACTION=="add|change", KERNEL=="sd*[!0-9]", ATTRS{queue/zoned}=="host-managed", ATTR{queue/scheduler}="deadline"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This rule sets up the ",(0,s.jsx)(n.em,{children:"deadline"})," scheduler for any host-managed zoned block\ndevice found in the system. A host-aware zoned block disk can accept random\nwrites and thus tolerate occasional write reordering within a zone sequential\nwrite stream. Nevertheless, write ordering can be maintained for these disks too\nby using the ",(0,s.jsx)(n.em,{children:"deadline"})," scheduler. The above ",(0,s.jsx)(n.em,{children:"udev"})," rule modified will\nautomatically enable this."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:'ACTION=="add|change", KERNEL=="sd*[!0-9]", ATTRS{queue/zoned}=="host-aware", ATTR{queue/scheduler}="deadline"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The following single rule enables the ",(0,s.jsx)(n.em,{children:"deadline"})," scheduler for any zoned\nblock device, regardless of the device zone model."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:'ACTION=="add|change", KERNEL=="sd*[!0-9]", ATTRS{queue/zoned}!="none", ATTR{queue/scheduler}="deadline"\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);