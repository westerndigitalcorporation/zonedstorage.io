"use strict";(self.webpackChunkzonedstorage_io=self.webpackChunkzonedstorage_io||[]).push([[9825],{4448:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var t=s(4848),i=s(8453);const o={id:"btrfs",title:"btrfs",sidebar_label:"btrfs"},r="btrfs File System",l={id:"filesystems/btrfs",title:"btrfs",description:"Btrfs is a file system based on the copy-on-write (CoW) principle. This",source:"@site/docs/filesystems/btrfs.md",sourceDirName:"filesystems",slug:"/filesystems/btrfs",permalink:"/docs/filesystems/btrfs",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"btrfs",title:"btrfs",sidebar_label:"btrfs"},sidebar:"docs",previous:{title:"Overview",permalink:"/docs/filesystems"},next:{title:"f2fs",permalink:"/docs/filesystems/f2fs"}},a={},c=[{value:"Usage",id:"usage",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Zoned Block Device Support",id:"zoned-block-device-support",level:3},{value:"Block Allocation Changes",id:"block-allocation-changes",level:3},{value:"I/O Management",id:"io-management",level:3},{value:"Zone Capacity Support",id:"zone-capacity-support",level:3},{value:"Limitations",id:"limitations",level:3},{value:"System Requirements",id:"system-requirements",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"btrfs-file-system",children:"btrfs File System"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Btrfs"})," is a file system based on the copy-on-write (CoW) principle. This\nprinciple has the result that no block update can be written in-place.\n",(0,t.jsx)(n.em,{children:"Btrfs"})," currently has experimental support for zoned block devices."]}),"\n",(0,t.jsx)(n.admonition,{title:"System Requirements",type:"note",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Linux kernel: 5.12+ (for SMR) or 5.16+ (for ZNS)."}),"\n",(0,t.jsx)(n.li,{children:"btrfs-progs: 5.12+ (for SMR) or 5.15+ (for ZNS)."}),"\n",(0,t.jsxs)(n.li,{children:["util-linux: 2.38+. More information can be found ",(0,t.jsx)(n.a,{href:"/docs/tools/util-linux",children:"here"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["I/O scheduler: ",(0,t.jsx)(n.a,{href:"/docs/linux/sched#block-io-scheduler-configuration",children:"mq-deadline to be configured for the block device"}),"."]}),"\n"]})}),"\n",(0,t.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,t.jsxs)(n.p,{children:["To format a zoned block device with ",(0,t.jsx)(n.em,{children:"mkfs.btrfs"}),", the ",(0,t.jsx)(n.code,{children:"-m single"})," and ",(0,t.jsx)(n.code,{children:"-d single"}),' options must be specified, because no block group profile other\nthan "single" is currently supported.']}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-plaintext",children:"# mkfs.btrfs -m single -d single /dev/sda\nbtrfs-progs v5.15.1\nSee http://btrfs.wiki.kernel.org for more information.\n\nZoned: /dev/sda: host-managed device detected, setting zoned feature\nResetting device zones /dev/sda (74508 zones) ...\nNOTE: several default settings have changed in version 5.15, please make sure\n      this does not affect your deployments:\n      - DUP for metadata (-m dup)\n      - enabled no-holes (-O no-holes)\n      - enabled free-space-tree (-R free-space-tree)\n\nLabel:              (null)\nUUID:               7ffa00fe-c6a3-4c6c-890f-858e17118c66\nNode size:          16384\nSector size:        4096\nFilesystem size:    18.19TiB\nBlock group profiles:\n  Data:             single          256.00MiB\n  Metadata:         single          256.00MiB\n  System:           single          256.00MiB\nSSD detected:       no\nZoned device:       yes\n  Zone size:        256.00MiB\nIncompat features:  extref, skinny-metadata, no-holes, zoned\nRuntime features:   free-space-tree\nChecksum:           crc32c\nNumber of devices:  1\nDevices:\n   ID        SIZE  PATH\n    1    18.19TiB  /dev/sda\n"})}),"\n",(0,t.jsx)(n.p,{children:"The formatted block device can now be directly mounted. No other setup is\nnecessary."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-plaintext",children:"# mount /dev/sda /mnt\n"})}),"\n",(0,t.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsx)(n.h3,{id:"zoned-block-device-support",children:"Zoned Block Device Support"}),"\n",(0,t.jsxs)(n.p,{children:["Zoned block device support was added to ",(0,t.jsx)(n.em,{children:"btrfs"})," with kernel 5.12. Because\nsuper-blocks are the only on-disk data structure with a fixed location in\n",(0,t.jsx)(n.em,{children:"btrfs"}),", zoned block device support introduces the concept of log-structured\nsuper-blocks to eliminate in-place updates (overwrites) of fixed super block\nlocations. Zoned mode reserves two consecutive zones to hold each of the\nsuper-blocks (primary and backup super-blocks) in ",(0,t.jsx)(n.em,{children:"btrfs"}),". When a new\nsuper-block is written, it is appended to its respective super-block zone.\nAfter the first super-block zone is filled, the next super block is written to\nthe second super-block zone and the first is reset. At mount time, ",(0,t.jsx)(n.em,{children:"btrfs"}),"\ncan find the latest version of the super-block by looking at the position of\nthe zone write pointer of the super-block zones. The most recent and valid\nsuper-block is always the last  block stored before the write pointer\nposition."]}),"\n",(0,t.jsx)(n.h3,{id:"block-allocation-changes",children:"Block Allocation Changes"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Btrfs"})," block management relies on grouping blocks into ",(0,t.jsx)(n.em,{children:"block groups"}),".\nEach ",(0,t.jsx)(n.em,{children:"block group"})," is composed of one or more ",(0,t.jsx)(n.em,{children:"device extents"}),". The device\nextents of a block group may belong to different devices (e.g. in the case\nof a RAID volume). ZBD support changes the size of a device extent from its\ndefault size to the size of the device zones. This ensures that all device\nextents are always aligned to a zone."]}),"\n",(0,t.jsx)(n.p,{children:"Allocation of blocks within a block group is changed so that the allocation is\nalways sequential from the beginning of the block group. To do this, an\nallocation pointer is added to block groups and used as the allocation hint.\nThese changes ensure that blocks freed below the allocation pointer are\nignored, which results in sequential block allocation within each group\nregardless of the block group usage."}),"\n",(0,t.jsx)(n.h3,{id:"io-management",children:"I/O Management"}),"\n",(0,t.jsx)(n.p,{children:'Although the introduction of the allocation pointer ensures that blocks are\nallocated sequentially within groups (and therefore sequentially within zones),\nI/O operations that write out newly allocated blocks can be issued out of\norder, and this can cause errors when writing to sequential zones. This problem\nis solved by introducing a "write I/O request staging list" to each block group.\nThis list is used to delay the execution of unaligned write requests within a\ngiven block group.'}),"\n",(0,t.jsx)(n.p,{children:"The zones of a block group are reset to allow rewriting only when the block\ngroup is free (that is, when all the blocks within the block group are\nunused)."}),"\n",(0,t.jsxs)(n.p,{children:["When dealing with ",(0,t.jsx)(n.em,{children:"btrfs"})," volumes that are composed of multiple disks,\nrestrictions are added to ensure that all the disks have the same zone model\n(and in the case of zoned block devices, the same zone size). This matches the\nexisting ",(0,t.jsx)(n.em,{children:"btrfs"})," constraint that dictates that all device extents in a block\ngroup must have the same size."]}),"\n",(0,t.jsxs)(n.p,{children:["All writes to data block groups use ",(0,t.jsx)(n.a,{href:"/docs/introduction/zns#zone-append",children:"Zone Append\nwriting"}),", which makes it possible to maintain\na high queue depth without violating the device zone's sequential write\nconstraints. Every write to dedicated meta-data block groups is serialized\nwith a file-system-global zoned metadata I/O lock."]}),"\n",(0,t.jsx)(n.h3,{id:"zone-capacity-support",children:"Zone Capacity Support"}),"\n",(0,t.jsxs)(n.p,{children:["SSDs with Zoned Namespace support can have a per ",(0,t.jsx)(n.a,{href:"/docs/introduction/zns#zone-capacity-and-zone-size",children:"zone capacity that is smaller than the zone\nsize"}),". To support such\ndevices, ",(0,t.jsx)(n.em,{children:"btrfs"})," ensures that block allocation and accounting considers only\nthe blocks in a zone that are within the zone capacity. This support for zone capacity has been available since Linux kernel version 5.16. Also,\nsince kernel 5.16, ",(0,t.jsx)(n.em,{children:"btrfs"}),' keeps track of the number of active zones on\na device and issues "Zone Finish" commands as needed.']}),"\n",(0,t.jsx)(n.h3,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsxs)(n.p,{children:["Not all features currently available in ",(0,t.jsx)(n.em,{children:"btrfs"})," are supported in the current\nzoned mode of the file-system."]}),"\n",(0,t.jsx)(n.p,{children:"These unavailable features include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"RAID Support"}),"\n",(0,t.jsx)(n.li,{children:"NOCOW Support"}),"\n",(0,t.jsx)(n.li,{children:"Support for fallocate(2)"}),"\n",(0,t.jsx)(n.li,{children:"Mixed data and meta-data block groups"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"system-requirements",children:"System Requirements"}),"\n",(0,t.jsxs)(n.p,{children:["In order to use ",(0,t.jsx)(n.em,{children:"btrfs"})," on zoned block devices, the following minimum system\nrequirements must be met:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Linux kernel 5.12 (for SMR) or 5.16 (for SSD /w ZNS support)"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"btrfs-progs"})," 5.12 (for SMR) or 5.15 (for SSD /w ZNS support)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"util-linux"})," 2.38"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The source code for ",(0,t.jsx)(n.em,{children:"btrfs-progs"})," ",(0,t.jsx)("a",{href:"https://github.com/kdave/btrfs-progs",target:"_blank",children:"is hosted on GitHub"}),". More information on ",(0,t.jsx)(n.em,{children:"util-linux"})," can be\nfound ",(0,t.jsx)(n.a,{href:"/docs/tools/util-linux",children:"here"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["If a kernel supports ",(0,t.jsx)(n.em,{children:"btrfs"})," on a zoned block device, it will automatically\nselect the ",(0,t.jsx)(n.em,{children:"mq_deadline"})," block IO scheduler by default. This ensures ",(0,t.jsx)(n.a,{href:"/docs/linux/sched",children:"write\nordering correctness"})," for any SMR hard-disk that is used in a\nzoned ",(0,t.jsx)(n.em,{children:"btrfs"})," volume."]}),"\n",(0,t.jsxs)(n.p,{children:["As in the case of an SSD with ZNS support, the ",(0,t.jsx)(n.em,{children:"mq-deadline"}),"\nscheduler must be set manually to ensure that the regular write operations used\nby ",(0,t.jsx)(n.em,{children:"btrfs"})," are delivered to the device in sequential order. For a NVMe zoned\nnamespace device ",(0,t.jsx)(n.em,{children:"/dev/nvmeXnY"}),", this is done with the following command:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-plaintext",children:"# echo mq-deadline > /sys/block/nvmeXnY/queue/scheduler\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Alternatively, the following udev rule can be used to automatically set the\n",(0,t.jsx)(n.em,{children:"mq-deadline"})," scheduler for all zoned block devices that have been formatted\nwith btrfs."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-plain",metastring:"text",children:'SUBSYSTEM!="block", GOTO="btrfs_end"\nACTION!="add|change", GOTO="btrfs_end"\nENV{ID_FS_TYPE}!="btrfs", GOTO="btrfs_end"\n\nATTR{queue/zoned}=="host-managed", ATTR{queue/scheduler}="mq-deadline"\n\nLABEL="btrfs_end"\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var t=s(6540);const i={},o=t.createContext(i);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);